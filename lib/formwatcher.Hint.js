// Generated by CoffeeScript 1.3.1
(function() {
  var __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor; child.__super__ = parent.prototype; return child; };

  Formwatcher.Decorators.push((function(_super) {

    __extends(_Class, _super);

    function _Class() {
      return _Class.__super__.constructor.apply(this, arguments);
    }

    _Class.prototype.name = "Hint";

    _Class.prototype.description = "Displays a hint in an input field.";

    _Class.prototype.nodeNames = ["INPUT", "TEXTAREA"];

    _Class.prototype.defaultOptions = {
      auto: true,
      removeTrailingColon: true,
      color: "#aaa"
    };

    _Class.prototype.decParseInt = function(number) {
      return parseInt(number, 10);
    };

    _Class.prototype.accepts = function(input) {
      if (_Class.__super__.accepts.call(this, input)) {
        if ((input.data("hint") != null) || (this.options.auto && Formwatcher.getLabel({
          input: input
        }, this.watcher.options.automatchLabel))) {
          return true;
        }
      }
      return false;
    };

    _Class.prototype.decorate = function(input) {
      var elements, hint, label, wrapper,
        _this = this;
      elements = {
        input: input
      };
      hint = input.data("hint");
      if (!(hint != null) || !hint) {
        label = Formwatcher.getLabel(elements, this.watcher.options.automatchLabel);
        if (!label) {
          throw "The hint was empty, but there was no label.";
        }
        elements.label = label;
        label.hide();
        hint = label.html();
        if (this.options.removeTrailingColon) {
          hint = hint.replace(/\s*\:\s*$/, "");
        }
      }
      Formwatcher.debug("Using hint: " + hint);
      wrapper = $.create("<span style=\"display: inline-block; position: relative;\" />");
      wrapper.insertAfter(input);
      wrapper.append(input);
      setTimeout(function() {
        var changeFunction, delayChangeFunction, fadeLength, hintElement, inputOffset, leftPosition, nextTimeout, topMargin, topPosition;
        topMargin = _this.decParseInt(input.css("marginTop"));
        if (isNaN(topMargin)) {
          topMargin = 0;
        }
        inputOffset = {
          left: input[0].offsetLeft,
          top: input[0].offsetTop,
          width: input[0].offsetWidth,
          height: input[0].offsetHeight
        };
        leftPosition = _this.decParseInt(input.css("paddingLeft")) + _this.decParseInt(inputOffset.left) + _this.decParseInt(input.css("borderLeftWidth")) + 2 + "px";
        topPosition = _this.decParseInt(input.css("paddingTop")) + _this.decParseInt(inputOffset.top) + _this.decParseInt(input.css("borderTopWidth")) + topMargin + "px";
        hintElement = $.create("<span />").html(hint).css({
          position: "absolute",
          display: "none",
          top: topPosition,
          left: leftPosition,
          fontSize: input.css("fontSize"),
          lineHeight: input.css("lineHeight"),
          fontFamily: input.css("fontFamily"),
          color: _this.options.color
        }).addClass("hint").on("click", function() {
          return input.focus();
        }).insertAfter(input);
        fadeLength = 100;
        input.focusin(function() {
          if (input.val() === "") {
            return hintElement.animate({
              opacity: 0.4,
              duration: fadeLength
            });
          }
        });
        input.focusout(function() {
          if (input.val() === "") {
            return hintElement.animate({
              opacity: 1,
              duration: fadeLength
            });
          }
        });
        changeFunction = function() {
          if (input.val() === "") {
            return hintElement.show();
          } else {
            return hintElement.hide();
          }
        };
        input.keyup(changeFunction);
        input.keypress(function() {
          return _.defer(changeFunction);
        });
        input.keydown(function() {
          return _.defer(changeFunction);
        });
        input.change(changeFunction);
        nextTimeout = 10;
        delayChangeFunction = function() {
          changeFunction();
          _.delay(delayChangeFunction, nextTimeout);
          nextTimeout = nextTimeout * 2;
          return nextTimeout = (nextTimeout > 10000 ? 10000 : nextTimeout);
        };
        return delayChangeFunction();
      }, 1);
      return elements;
    };

    return _Class;

  })(Formwatcher.Decorator));

}).call(this);
